{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport deepmerge from 'deepmerge';\n\n/**\r\n * Created by championswimmer on 22/07/17.\r\n */\nlet MockStorage;\n// @ts-ignore\n{\n  MockStorage = class {\n    get length() {\n      return Object.keys(this).length;\n    }\n    key(index) {\n      return Object.keys(this)[index];\n    }\n    setItem(key, data) {\n      this[key] = data.toString();\n    }\n    getItem(key) {\n      return this[key];\n    }\n    removeItem(key) {\n      delete this[key];\n    }\n    clear() {\n      for (let key of Object.keys(this)) {\n        delete this[key];\n      }\n    }\n  };\n}\n\n// tslint:disable: variable-name\nclass SimplePromiseQueue {\n  constructor() {\n    this._queue = [];\n    this._flushing = false;\n  }\n  enqueue(promise) {\n    this._queue.push(promise);\n    if (!this._flushing) {\n      return this.flushQueue();\n    }\n    return Promise.resolve();\n  }\n  flushQueue() {\n    this._flushing = true;\n    const chain = () => {\n      const nextTask = this._queue.shift();\n      if (nextTask) {\n        return nextTask.then(chain);\n      } else {\n        this._flushing = false;\n      }\n    };\n    return Promise.resolve(chain());\n  }\n}\nconst options = {\n  replaceArrays: {\n    arrayMerge: (destinationArray, sourceArray, options) => sourceArray\n  },\n  concatArrays: {\n    arrayMerge: (target, source, options) => target.concat(...source)\n  }\n};\nfunction merge(into, from, mergeOption) {\n  return deepmerge(into, from, options[mergeOption]);\n}\nlet FlattedJSON = JSON;\n/**\r\n * A class that implements the vuex persistence.\r\n * @type S type of the 'state' inside the store (default: any)\r\n */\nclass VuexPersistence {\n  /**\r\n   * Create a {@link VuexPersistence} object.\r\n   * Use the <code>plugin</code> function of this class as a\r\n   * Vuex plugin.\r\n   * @param {PersistOptions} options\r\n   */\n  constructor(options) {\n    // tslint:disable-next-line:variable-name\n    this._mutex = new SimplePromiseQueue();\n    /**\r\n     * Creates a subscriber on the store. automatically is used\r\n     * when this is used a vuex plugin. Not for manual usage.\r\n     * @param store\r\n     */\n    this.subscriber = store => handler => store.subscribe(handler);\n    if (typeof options === 'undefined') options = {};\n    this.key = options.key != null ? options.key : 'vuex';\n    this.subscribed = false;\n    this.supportCircular = options.supportCircular || false;\n    if (this.supportCircular) {\n      FlattedJSON = require('flatted');\n    }\n    this.mergeOption = options.mergeOption || 'replaceArrays';\n    let localStorageLitmus = true;\n    try {\n      window.localStorage.getItem('');\n    } catch (err) {\n      localStorageLitmus = false;\n    }\n    /**\r\n     * 1. First, prefer storage sent in optinos\r\n     * 2. Otherwise, use window.localStorage if available\r\n     * 3. Finally, try to use MockStorage\r\n     * 4. None of above? Well we gotta fail.\r\n     */\n    if (options.storage) {\n      this.storage = options.storage;\n    } else if (localStorageLitmus) {\n      this.storage = window.localStorage;\n    } else if (MockStorage) {\n      this.storage = new MockStorage();\n    } else {\n      throw new Error(\"Neither 'window' is defined, nor 'MockStorage' is available\");\n    }\n    /**\r\n     * How this works is -\r\n     *  1. If there is options.reducer function, we use that, if not;\r\n     *  2. We check options.modules;\r\n     *    1. If there is no options.modules array, we use entire state in reducer\r\n     *    2. Otherwise, we create a reducer that merges all those state modules that are\r\n     *        defined in the options.modules[] array\r\n     * @type {((state: S) => {}) | ((state: S) => S) | ((state: any) => {})}\r\n     */\n    this.reducer = options.reducer != null ? options.reducer : options.modules == null ? state => state : state => options.modules.reduce((a, i) => merge(a, {\n      [i]: state[i]\n    }, this.mergeOption), {/* start empty accumulator*/});\n    this.filter = options.filter || (mutation => true);\n    this.strictMode = options.strictMode || false;\n    this.RESTORE_MUTATION = function RESTORE_MUTATION(state, savedState) {\n      const mergedState = merge(state, savedState || {}, this.mergeOption);\n      for (const propertyName of Object.keys(mergedState)) {\n        this._vm.$set(state, propertyName, mergedState[propertyName]);\n      }\n    };\n    this.asyncStorage = options.asyncStorage || false;\n    if (this.asyncStorage) {\n      /**\r\n       * Async {@link #VuexPersistence.restoreState} implementation\r\n       * @type {((key: string, storage?: Storage) =>\r\n       *      (Promise<S> | S)) | ((key: string, storage: AsyncStorage) => Promise<any>)}\r\n       */\n      this.restoreState = options.restoreState != null ? options.restoreState : (key, storage) => storage.getItem(key).then(value => typeof value === 'string' // If string, parse, or else, just return\n      ? this.supportCircular ? FlattedJSON.parse(value || '{}') : JSON.parse(value || '{}') : value || {});\n      /**\r\n       * Async {@link #VuexPersistence.saveState} implementation\r\n       * @type {((key: string, state: {}, storage?: Storage) =>\r\n       *    (Promise<void> | void)) | ((key: string, state: {}, storage?: Storage) => Promise<void>)}\r\n       */\n      this.saveState = options.saveState != null ? options.saveState : (key, state, storage) => storage.setItem(key,\n      // Second argument is state _object_ if asyc storage, stringified otherwise\n      // do not stringify the state if the storage type is async\n      this.asyncStorage ? merge({}, state || {}, this.mergeOption) : this.supportCircular ? FlattedJSON.stringify(state) : JSON.stringify(state));\n      /**\r\n       * Async version of plugin\r\n       * @param {Store<S>} store\r\n       */\n      this.plugin = store => {\n        /**\r\n         * For async stores, we're capturing the Promise returned\r\n         * by the `restoreState()` function in a `restored` property\r\n         * on the store itself. This would allow app developers to\r\n         * determine when and if the store's state has indeed been\r\n         * refreshed. This approach was suggested by GitHub user @hotdogee.\r\n         * See https://github.com/championswimmer/vuex-persist/pull/118#issuecomment-500914963\r\n         * @since 2.1.0\r\n         */\n        store.restored = this.restoreState(this.key, this.storage).then(savedState => {\n          /**\r\n           * If in strict mode, do only via mutation\r\n           */\n          if (this.strictMode) {\n            store.commit('RESTORE_MUTATION', savedState);\n          } else {\n            store.replaceState(merge(store.state, savedState || {}, this.mergeOption));\n          }\n          this.subscriber(store)((mutation, state) => {\n            if (this.filter(mutation)) {\n              this._mutex.enqueue(this.saveState(this.key, this.reducer(state), this.storage));\n            }\n          });\n          this.subscribed = true;\n        });\n      };\n    } else {\n      /**\r\n       * Sync {@link #VuexPersistence.restoreState} implementation\r\n       * @type {((key: string, storage?: Storage) =>\r\n       *    (Promise<S> | S)) | ((key: string, storage: Storage) => (any | string | {}))}\r\n       */\n      this.restoreState = options.restoreState != null ? options.restoreState : (key, storage) => {\n        const value = storage.getItem(key);\n        if (typeof value === 'string') {\n          // If string, parse, or else, just return\n          return this.supportCircular ? FlattedJSON.parse(value || '{}') : JSON.parse(value || '{}');\n        } else {\n          return value || {};\n        }\n      };\n      /**\r\n       * Sync {@link #VuexPersistence.saveState} implementation\r\n       * @type {((key: string, state: {}, storage?: Storage) =>\r\n       *     (Promise<void> | void)) | ((key: string, state: {}, storage?: Storage) => Promise<void>)}\r\n       */\n      this.saveState = options.saveState != null ? options.saveState : (key, state, storage) => storage.setItem(key,\n      // Second argument is state _object_ if localforage, stringified otherwise\n      this.supportCircular ? FlattedJSON.stringify(state) : JSON.stringify(state));\n      /**\r\n       * Sync version of plugin\r\n       * @param {Store<S>} store\r\n       */\n      this.plugin = store => {\n        const savedState = this.restoreState(this.key, this.storage);\n        if (this.strictMode) {\n          store.commit('RESTORE_MUTATION', savedState);\n        } else {\n          store.replaceState(merge(store.state, savedState || {}, this.mergeOption));\n        }\n        this.subscriber(store)((mutation, state) => {\n          if (this.filter(mutation)) {\n            this.saveState(this.key, this.reducer(state), this.storage);\n          }\n        });\n        this.subscribed = true;\n      };\n    }\n  }\n}\nexport default VuexPersistence;\nexport { MockStorage, VuexPersistence };","map":{"version":3,"mappings":"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","names":["MockStorage","length","Object","keys","key","index","setItem","data","toString","getItem","removeItem","clear","SimplePromiseQueue","constructor","enqueue","promise","_queue","push","_flushing","flushQueue","Promise","resolve","chain","nextTask","shift","then","options","replaceArrays","arrayMerge","destinationArray","sourceArray","concatArrays","target","source","concat","merge","into","from","mergeOption","deepmerge","FlattedJSON","JSON","VuexPersistence","store","handler","subscribe","subscribed","supportCircular","require","localStorageLitmus","window","localStorage","err","storage","Error","reducer","modules","state","reduce","a","i","filter","mutation","strictMode","RESTORE_MUTATION","savedState","mergedState","propertyName","_vm","$set","asyncStorage","restoreState","value","parse","saveState","stringify","plugin","restored","commit","replaceState","subscriber","_mutex"],"sources":["../../src/MockStorage.ts","../../src/SimplePromiseQueue.ts","../../src/utils.ts","../../src/index.ts"],"sourcesContent":["/**\n * Created by championswimmer on 22/07/17.\n */\nlet MockStorage: typeof Storage | undefined\n\n// @ts-ignore\nif (process.env.MODULE_FORMAT !== 'umd') {\n  MockStorage = class implements Storage {\n    [index: number]: string;\n    [key: string]: any;\n\n    public get length(): number {\n      return Object.keys(this).length\n    }\n\n    public key(index: number): string | any {\n      return Object.keys(this)[index]\n    }\n\n    public setItem(key: string, data: any): void {\n      this[key] = data.toString()\n    }\n    public getItem(key: string): string {\n      return this[key]\n    }\n    public removeItem(key: string): void {\n      delete this[key]\n    }\n    public clear(): void {\n      for (let key of Object.keys(this)) {\n        delete this[key]\n      }\n    }\n  }\n}\n\nexport { MockStorage }\n","// tslint:disable: variable-name\nexport default class SimplePromiseQueue {\n  private readonly _queue: Array<Promise<void>> = []\n  private _flushing = false\n\n  public enqueue(promise: Promise<void>) {\n    this._queue.push(promise)\n    if (!this._flushing) { return this.flushQueue() }\n    return Promise.resolve()\n  }\n\n  private flushQueue() {\n    this._flushing = true\n\n    const chain = (): Promise<void> | void => {\n      const nextTask = this._queue.shift()\n      if (nextTask) {\n        return nextTask.then(chain)\n      } else {\n        this._flushing = false\n      }\n    }\n    return Promise.resolve(chain())\n  }\n}\n","import deepmerge from 'deepmerge'\n\nexport type MergeOptionType = 'replaceArrays' | 'concatArrays'\n\nconst options: {[k in MergeOptionType]: deepmerge.Options} = {\n  replaceArrays: {\n    arrayMerge: (destinationArray, sourceArray, options) => sourceArray\n  },\n  concatArrays: {\n    arrayMerge: (target, source, options) => target.concat(...source)\n  }\n}\n\nconst defaultMergeOptions: deepmerge.Options = {\n  // replacing arrays\n  \n}\n\nexport function merge<I, F>(into: Partial<I>, from: Partial<F>, mergeOption: MergeOptionType): I & F & {} {\n  return deepmerge(into, from, options[mergeOption])\n}\n","/**\n * Created by championswimmer on 18/07/17.\n */\nimport { Mutation, MutationPayload, Payload, Plugin, Store } from 'vuex'\nimport { AsyncStorage } from './AsyncStorage'\nimport { MockStorage } from './MockStorage'\nimport { PersistOptions } from './PersistOptions'\nimport SimplePromiseQueue from './SimplePromiseQueue'\nimport { merge, MergeOptionType } from './utils'\n\nlet FlattedJSON = JSON\n\n/**\n * A class that implements the vuex persistence.\n * @type S type of the 'state' inside the store (default: any)\n */\nexport class VuexPersistence<S> implements PersistOptions<S> {\n  public asyncStorage: boolean\n  public storage: Storage | AsyncStorage | undefined\n  public restoreState: (key: string, storage?: AsyncStorage | Storage) => Promise<S> | S\n  public saveState: (key: string, state: {}, storage?: AsyncStorage | Storage) => Promise<void> | void\n  public reducer: (state: S) => Partial<S>\n  public key: string\n  public filter: (mutation: Payload) => boolean\n  public modules: string[]\n  public strictMode: boolean\n  public supportCircular: boolean\n  public mergeOption: MergeOptionType\n\n  /**\n   * The plugin function that can be used inside a vuex store.\n   */\n  public plugin: Plugin<S>\n  /**\n   * A mutation that can be used to restore state\n   * Helpful if we are running in strict mode\n   */\n  public RESTORE_MUTATION: Mutation<S>\n  public subscribed: boolean\n\n  // tslint:disable-next-line:variable-name\n  private _mutex = new SimplePromiseQueue()\n\n  /**\n   * Create a {@link VuexPersistence} object.\n   * Use the <code>plugin</code> function of this class as a\n   * Vuex plugin.\n   * @param {PersistOptions} options\n   */\n  public constructor(options?: PersistOptions<S>) {\n    if (typeof options === 'undefined') options = {} as PersistOptions<S>\n    this.key = ((options.key != null) ? options.key : 'vuex')\n\n    this.subscribed = false\n    this.supportCircular = options.supportCircular || false\n    if (this.supportCircular) {\n      FlattedJSON = require('flatted')\n    }\n    this.mergeOption = options.mergeOption || 'replaceArrays'\n\n    let localStorageLitmus = true\n\n    try {\n      window.localStorage.getItem('')\n    } catch (err) {\n      localStorageLitmus = false\n    }\n\n    /**\n     * 1. First, prefer storage sent in optinos\n     * 2. Otherwise, use window.localStorage if available\n     * 3. Finally, try to use MockStorage\n     * 4. None of above? Well we gotta fail.\n     */\n    if (options.storage) { this.storage = options.storage }\n    else if (localStorageLitmus) { this.storage = window.localStorage }\n    else if (MockStorage) { this.storage = new MockStorage() }\n    else { throw new Error(\"Neither 'window' is defined, nor 'MockStorage' is available\") }\n\n    /**\n     * How this works is -\n     *  1. If there is options.reducer function, we use that, if not;\n     *  2. We check options.modules;\n     *    1. If there is no options.modules array, we use entire state in reducer\n     *    2. Otherwise, we create a reducer that merges all those state modules that are\n     *        defined in the options.modules[] array\n     * @type {((state: S) => {}) | ((state: S) => S) | ((state: any) => {})}\n     */\n    this.reducer = (\n      (options.reducer != null)\n        ? options.reducer\n        : (\n          (options.modules == null)\n            ? ((state: S) => state)\n            : (\n              (state: any) =>\n                (options!.modules as string[]).reduce((a, i) =>\n                  merge(a, { [i]: state[i] }, this.mergeOption), {/* start empty accumulator*/ })\n            )\n        )\n    )\n\n    this.filter = options.filter || ((mutation) => true)\n\n    this.strictMode = options.strictMode || false\n\n    this.RESTORE_MUTATION = function RESTORE_MUTATION(state: S, savedState: any) {\n      const mergedState = merge(state, savedState || {}, this.mergeOption)\n      for (const propertyName of Object.keys(mergedState as {})) {\n        (this as any)._vm.$set(state, propertyName, (mergedState as any)[propertyName])\n      }\n    }\n\n    this.asyncStorage = options.asyncStorage || false\n\n    if (this.asyncStorage) {\n\n      /**\n       * Async {@link #VuexPersistence.restoreState} implementation\n       * @type {((key: string, storage?: Storage) =>\n       *      (Promise<S> | S)) | ((key: string, storage: AsyncStorage) => Promise<any>)}\n       */\n      this.restoreState = (\n        (options.restoreState != null)\n          ? options.restoreState\n          : ((key: string, storage: AsyncStorage) =>\n            (storage).getItem(key)\n              .then((value) =>\n                typeof value === 'string' // If string, parse, or else, just return\n                  ? (\n                    this.supportCircular\n                      ? FlattedJSON.parse(value || '{}')\n                      : JSON.parse(value || '{}')\n                  )\n                  : (value || {})\n              )\n          )\n      )\n\n      /**\n       * Async {@link #VuexPersistence.saveState} implementation\n       * @type {((key: string, state: {}, storage?: Storage) =>\n       *    (Promise<void> | void)) | ((key: string, state: {}, storage?: Storage) => Promise<void>)}\n       */\n      this.saveState = (\n        (options.saveState != null)\n          ? options.saveState\n          : ((key: string, state: {}, storage: AsyncStorage) =>\n            (storage).setItem(\n              key, // Second argument is state _object_ if asyc storage, stringified otherwise\n              // do not stringify the state if the storage type is async\n              (this.asyncStorage\n                ? merge({}, state || {}, this.mergeOption)\n                : (\n                  this.supportCircular\n                    ? FlattedJSON.stringify(state) as any\n                    : JSON.stringify(state) as any\n                )\n              )\n            )\n          )\n      )\n\n      /**\n       * Async version of plugin\n       * @param {Store<S>} store\n       */\n      this.plugin = (store: Store<S>) => {\n        /**\n         * For async stores, we're capturing the Promise returned\n         * by the `restoreState()` function in a `restored` property\n         * on the store itself. This would allow app developers to\n         * determine when and if the store's state has indeed been\n         * refreshed. This approach was suggested by GitHub user @hotdogee.\n         * See https://github.com/championswimmer/vuex-persist/pull/118#issuecomment-500914963\n         * @since 2.1.0\n         */\n        (store as any).restored = ((this.restoreState(this.key, this.storage)) as Promise<S>).then((savedState) => {\n          /**\n           * If in strict mode, do only via mutation\n           */\n          if (this.strictMode) {\n            store.commit('RESTORE_MUTATION', savedState)\n          } else {\n            store.replaceState(merge(store.state, savedState || {}, this.mergeOption) as S)\n          }\n          this.subscriber(store)((mutation: MutationPayload, state: S) => {\n            if (this.filter(mutation)) {\n              this._mutex.enqueue(\n                this.saveState(this.key, this.reducer(state), this.storage) as Promise<void>\n              )\n            }\n          })\n          this.subscribed = true\n        })\n      }\n    } else {\n\n      /**\n       * Sync {@link #VuexPersistence.restoreState} implementation\n       * @type {((key: string, storage?: Storage) =>\n       *    (Promise<S> | S)) | ((key: string, storage: Storage) => (any | string | {}))}\n       */\n      this.restoreState = (\n        (options.restoreState != null)\n          ? options.restoreState\n          : ((key: string, storage: Storage) => {\n            const value = (storage).getItem(key)\n            if (typeof value === 'string') {// If string, parse, or else, just return\n              return (\n                this.supportCircular\n                  ? FlattedJSON.parse(value || '{}')\n                  : JSON.parse(value || '{}')\n              )\n            } else {\n              return (value || {})\n            }\n          })\n      )\n\n      /**\n       * Sync {@link #VuexPersistence.saveState} implementation\n       * @type {((key: string, state: {}, storage?: Storage) =>\n       *     (Promise<void> | void)) | ((key: string, state: {}, storage?: Storage) => Promise<void>)}\n       */\n      this.saveState = (\n        (options.saveState != null)\n          ? options.saveState\n          : ((key: string, state: {}, storage: Storage) =>\n            (storage).setItem(\n              key, // Second argument is state _object_ if localforage, stringified otherwise\n              (\n                this.supportCircular\n                  ? FlattedJSON.stringify(state) as any\n                  : JSON.stringify(state) as any\n              )\n            )\n          )\n      )\n\n      /**\n       * Sync version of plugin\n       * @param {Store<S>} store\n       */\n      this.plugin = (store: Store<S>) => {\n        const savedState = this.restoreState(this.key, this.storage) as S\n\n        if (this.strictMode) {\n          store.commit('RESTORE_MUTATION', savedState)\n        } else {\n          store.replaceState(merge(store.state, savedState || {}, this.mergeOption) as S)\n        }\n\n        this.subscriber(store)((mutation: MutationPayload, state: S) => {\n          if (this.filter(mutation)) {\n            this.saveState(this.key, this.reducer(state), this.storage)\n          }\n        })\n\n        this.subscribed = true\n      }\n    }\n  }\n\n  /**\n   * Creates a subscriber on the store. automatically is used\n   * when this is used a vuex plugin. Not for manual usage.\n   * @param store\n   */\n  private subscriber = (store: Store<S>) =>\n    (handler: (mutation: MutationPayload, state: S) => any) => store.subscribe(handler)\n}\n\nexport {\n  MockStorage, AsyncStorage, PersistOptions\n}\n\nexport default VuexPersistence\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}